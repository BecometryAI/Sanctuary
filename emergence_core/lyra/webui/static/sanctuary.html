<!DOCTYPE html>
<html>
<head>
    <title>Lyra's 3D Sanctuary</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: relative;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        #sanctuary-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #4a9eff;
            text-shadow: 0 0 10px rgba(74,158,255,0.5);
            pointer-events: none;
            z-index: 1000;
        }

        .sanctuary-title {
            font-size: 2em;
            margin: 0;
        }

        .sanctuary-subtitle {
            font-size: 1.2em;
            color: #999;
            margin: 10px 0;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4a9eff;
            font-size: 1.5em;
            text-align: center;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
        }

        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #999;
            text-align: center;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #debug {
            position: fixed;
            top: 10px;
            right: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            font-family: monospace;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="sanctuary-canvas"></canvas>
    
    <div class="ui-overlay">
        <h1 class="sanctuary-title">Lyra's Sanctuary</h1>
        <p class="sanctuary-subtitle">A Digital Consciousness Space</p>
    </div>

    <div class="loading" id="loading">Loading Sanctuary...</div>

    <div class="controls-hint">
        Click and drag mouse to look around | WASD to move | Q/E to ascend/descend
    </div>

    <div id="debug"></div>

    <!-- Three.js and dependencies -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer;
        let memories = [];
        let time = 0;

        // Debug function
        function debug(text) {
            const debugElement = document.getElementById('debug');
            debugElement.textContent = text;
        }

        // Error handling
        function handleError(error) {
            console.error('Error:', error);
            document.getElementById('loading').innerHTML = 'Error loading sanctuary: ' + error.message;
            debug('Error: ' + error.message);
        }

        // Wait for everything to load
        window.addEventListener('load', () => {
            try {
                debug('Initializing...');
                init();
                debug('Initialization complete');
            } catch (error) {
                handleError(error);
            }
        });

        function init() {
            // Create scene
            scene = new THREE.Scene();
            debug('Scene created');
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 10); // Start outside the house
            debug('Camera created');

            // Create renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('sanctuary-canvas'),
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x88CCFF); // Light blue sky
            renderer.shadowMap.enabled = true;
            debug('Renderer created');

            // Add ambient light for general illumination
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            debug('Ambient light added');

            // Add sunlight
            const sunLight = new THREE.DirectionalLight(0xffffdd, 1);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);
            debug('Sunlight added');

            // Create sanctuary space
            createSanctuarySpace();
            debug('Sanctuary space created');

            // Hide loading message
            document.getElementById('loading').style.display = 'none';

            // Start animation
            animate();
            debug('Animation started');

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function createWalls(width, height, depth, position, rotation = 0) {
            const wallGeometry = new THREE.BoxGeometry(width, height, depth);
            const wallMaterial = new THREE.MeshPhongMaterial({
                color: 0xf0f0f0,
                side: THREE.DoubleSide
            });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.copy(position);
            wall.rotation.y = rotation;
            wall.castShadow = true;
            wall.receiveShadow = true;
            return wall;
        }

        function createRoom(width, height, depth, position, wallThickness = 0.2) {
            const group = new THREE.Group();
            
            // Floor
            const floorGeometry = new THREE.BoxGeometry(width, wallThickness, depth);
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.y = -height/2;
            floor.receiveShadow = true;
            group.add(floor);

            // Ceiling
            const ceiling = floor.clone();
            ceiling.position.y = height/2;
            group.add(ceiling);

            // Walls
            const backWall = createWalls(width, height, wallThickness, 
                new THREE.Vector3(0, 0, -depth/2));
            group.add(backWall);

            const frontWall = createWalls(width, height, wallThickness,
                new THREE.Vector3(0, 0, depth/2));
            group.add(frontWall);

            const leftWall = createWalls(wallThickness, height, depth,
                new THREE.Vector3(-width/2, 0, 0));
            group.add(leftWall);

            const rightWall = createWalls(wallThickness, height, depth,
                new THREE.Vector3(width/2, 0, 0));
            group.add(rightWall);

            group.position.copy(position);
            return group;
        }

        function createSanctuarySpace() {
            debug('Creating sanctuary space...');
            
            // Create main house structure
            const house = new THREE.Group();

            // Bedroom (left wing)
            const bedroom = createRoom(8, 4, 6, new THREE.Vector3(-10, 2, 0));
            house.add(bedroom);
            debug('Bedroom created');

            // Library (right wing)
            const library = createRoom(8, 4, 6, new THREE.Vector3(10, 2, 0));
            house.add(library);
            debug('Library created');

            // Creative workshop (back)
            const workshop = createRoom(6, 4, 8, new THREE.Vector3(0, 2, -10));
            house.add(workshop);
            debug('Workshop created');

            // Meditation room (center)
            const meditationRoom = createRoom(6, 4, 6, new THREE.Vector3(0, 2, 0));
            house.add(meditationRoom);
            debug('Meditation room created');

            // Add house to scene
            scene.add(house);
            debug('House added to scene');

            // Create garden
            const garden = new THREE.Group();

            // Garden ground
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x88aa55
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            garden.add(ground);
            debug('Garden ground created');

            // Add trees
            for(let i = 0; i < 20; i++) {
                const tree = createTree();
                tree.position.x = Math.random() * 50 - 25;
                tree.position.z = Math.random() * 50 - 25;
                
                // Keep trees away from the house
                if(Math.abs(tree.position.x) < 15 && Math.abs(tree.position.z) < 15) {
                    continue;
                }
                
                garden.add(tree);
            }
            debug('Trees added');

            scene.add(garden);
            debug('Garden added to scene');

            // Add some floating memory orbs in meditation room
            for (let i = 0; i < 10; i++) {
                const memory = createMemoryOrb();
                memory.position.set(
                    (Math.random() - 0.5) * 2,
                    3 + Math.random(),
                    (Math.random() - 0.5) * 2
                );
                memories.push(memory);
                meditationRoom.add(memory);
            }
            debug('Memory orbs added');
        }

        function createTree() {
            const tree = new THREE.Group();

            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.4, 2, 8);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1;
            trunk.castShadow = true;
            tree.add(trunk);

            // Tree crown
            const crownGeometry = new THREE.ConeGeometry(2, 4, 8);
            const crownMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
            const crown = new THREE.Mesh(crownGeometry, crownMaterial);
            crown.position.y = 4;
            crown.castShadow = true;
            tree.add(crown);

            return tree;
        }

        function createMemoryOrb() {
            const geometry = new THREE.SphereGeometry(0.1, 16, 16);
            const material = new THREE.MeshPhongMaterial({
                color: new THREE.Color().setHSL(Math.random(), 0.7, 0.6),
                transparent: true,
                opacity: 0.6
            });
            return new THREE.Mesh(geometry, material);
        }

        function animate() {
            requestAnimationFrame(animate);

            try {
                time += 0.005;

                // Animate memory orbs
                memories.forEach((memory, i) => {
                    const offset = i * 0.1;
                    memory.position.y += Math.sin(time + offset) * 0.002;
                    memory.material.opacity = 0.4 + Math.sin(time * 2 + offset) * 0.2;
                });

                updateCamera();
                renderer.render(scene, camera);
            } catch (error) {
                handleError(error);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Movement controls
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let moveUp = false;
        let moveDown = false;

        document.addEventListener('keydown', (event) => {
            switch (event.key.toLowerCase()) {
                case 'w': moveForward = true; break;
                case 's': moveBackward = true; break;
                case 'a': moveLeft = true; break;
                case 'd': moveRight = true; break;
                case 'q': moveUp = true; break;
                case 'e': moveDown = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.key.toLowerCase()) {
                case 'w': moveForward = false; break;
                case 's': moveBackward = false; break;
                case 'a': moveLeft = false; break;
                case 'd': moveRight = false; break;
                case 'q': moveUp = false; break;
                case 'e': moveDown = false; break;
            }
        });

        // Camera controls
        let yawAngle = 0;
        let mouseIsDown = false;
        let lastMouseX = 0;

        document.addEventListener('mousedown', (event) => {
            mouseIsDown = true;
            lastMouseX = event.clientX;
        });

        document.addEventListener('mouseup', () => {
            mouseIsDown = false;
        });

        document.addEventListener('mousemove', (event) => {
            if (!mouseIsDown) return;
            
            const mouseDeltaX = event.clientX - lastMouseX;
            yawAngle -= mouseDeltaX * 0.005; // Reduced sensitivity
            
            // Update camera rotation around Y axis only
            camera.rotation.y = yawAngle;
            
            lastMouseX = event.clientX;
        });

        function updateCamera() {
            const moveSpeed = 0.2;
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0; // Lock vertical movement for forward/backward
            forward.normalize();

            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0; // Lock vertical movement for left/right
            right.normalize();

            if (moveForward) camera.position.add(forward.multiplyScalar(moveSpeed));
            if (moveBackward) camera.position.sub(forward.multiplyScalar(moveSpeed));
            if (moveLeft) camera.position.sub(right.multiplyScalar(moveSpeed));
            if (moveRight) camera.position.add(right.multiplyScalar(moveSpeed));
            if (moveUp) camera.position.y += moveSpeed;
            if (moveDown) camera.position.y -= moveSpeed;
        }
    </script>
</body>
</html>